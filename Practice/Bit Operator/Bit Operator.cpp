#include <iostream>

//요약
//BoolArr라는 boolean 배열에 N번쨰 인덱스에 대한 True False 조작 및 체크
#define On(BoolArr, N) BoolArr |= (1 << N)
#define Off(BoolArr, N) BoolArr &= ~(1 << N)
#define Switch(BoolArr, N) BoolArr ^= (1 << N)
#define IsOn(BoolArr, N) (BoolArr>> N) & 1

int main()
{
	//시작하기 전 유의사항
	//자료형에 굉장히 민감하며, 컴파일 오류 체크(경고로는 뜸)가 안되기 때문에 주의해서 사용해야함
	//만약 내가 long long 자료형을 사용한다면 반드시 10LL등 상수에도 자료형 표기를 명확하게 해주어야함
	//int : 10
	//long : 10L
	//long long : 10LL

	int Answer = 0;
	
	//비트가 0은 false, 1은 true라고 생각하면 직관적
	
	// & : AND 연산자 두 비트가 1이면 1 아니면 0////////////////////////////////////////////
	Answer = 3 & 2;
	//int 3의 비트는 11, 2의 비트는 10
	//대응하는 비트를 비교
	//11 = 3
	//10 = 2
	//==
	//10 = 2

	//자릿수가 다르다면?(비트값 기준으로)
	Answer = 10 & 3;
	//10과 3
	//1010 = 10
	//0011 = 3
	//====
	//0010 = 2
	//더 긴 자릿수를 기준으로 비트를 비교

	// | : OR 연산자 두 비트 중 하나만 1이면 1, 아니면 0////////////////////////////////////////////
	Answer = 3 | 2;
	//11 = 3
	//10 = 2
	//==
	//11 = 3

	Answer = 10 | 3;
	//1010 = 10
	//0011 = 3
	//====
	//1011 = 11

	// ^ : XOR 연산자, 서로 다른 비트면 1을 반환함////////////////////////////////////////////
	Answer = 3 ^ 2;
	//11 = 3
	//10 = 2
	//==
	//01 = 1

	Answer = 10 ^ 3;
	//1010 = 10
	//0011 = 3
	//====
	//1001 = 9
	
	// ~ : NOT 연산자, 비트가 1이면 0, 0이면 1을 반환////////////////////////////////////////////
	Answer = ~3;
	//00000000 00000000 00000000 00000011 = 3
	//======== ======== ======== ======== 
	//11111111 11111111 11111111 11111100 = -4

	Answer = 10;
	//00000000 00000000 00000000 00001010 = 10
	//======== ======== ======== ========
	//11111111 11111111 11111111 11110101 = -11
	//모든 비트를 반전시킴(MSB까지!!), 보수 연산

	// << : 왼쪽 시프트 연산자, 비트를 지정한 숫자만큼 왼쪽으로 이동시킴////////////////////////////////////////////
	Answer = 10 << 2;
	//1010 = 10
	//101000 = 40
	//왼쪽으로 한칸 밀때마다 2를 곱한것과 같음.
	//단! 전체 메모리를 넘어가는 연산을 하게되면 그만큼 데이터가 소실됨

	// >> : 오른쪽 시프트 연산자, 비트를 지정한 숫자만큼 오른쪽으로 이동시킴////////////////////////////////////////////
	Answer = 10 >> 1;
	//1010 = 10
	//101 = 5
	//오른쪽으로 한칸 밀때마다 2를 나눈것과 같음.
	//단! 전체 메모리를 넘어가는 연산을 하게되면 그만큼 데이터가 소실됨

	//이를 이용해서 특정 비트값만 바꾸는 함수를 만들기
	int n = 2;
	Answer = 10; //0b 1010
	
	//1. n번째 비트값을 1로 만드든 연산//////////////////////////////////////////////
	//Answer |= 1 << n;
	On(Answer, n);

	//분석 : Answer = 10, n == 2일때
	//Answer = Answer | (1 << 2); 이걸로 쓸수 있음
	//Answer = 10 | 4; 임
	//1010 = 10
	//0100 = 4
	//====
	//1110 = 14 -> 결과적으로 1이 있는 곳만 영향을 주게 되어있음.
	//1을 해당 자릿수로 옮기고 OR 연산을 하면 해당 자릿수가 0이던 1이던 1로 만들어 버림

	//2. n번째 비트값을 0으로 만드는 연산//////////////////////////////////////////////
	n = 1;
	Answer = 10;
	//Answer &= ~(1 << n);
	Off(Answer, n);
	
	//분석 : Answer = 10, n == 1일때
	//Answer = Answer & ~(1 << 1); 이걸로 쓸수 있음
	//Answer = 10 & ~2
	//00000000 00000000 00000000 00001010 = 10
	//11111111 11111111 11111111 11111101 = ~2
	//======== ======== ======== ========
	//00000000 00000000 00000000 00001000 = 8
	//결과적으로 0이 있는 곳만 영향을 주게 되어있음
	//0을 해당 자릿수로 옮기고 AND 연산을 하면 해당 자릿수가 0이던 1이던 0로 만들어 버림

	//3. n번째 비트값이 1이면 0, 0이면 1로 바꾸는 연산//////////////////////////////////////////////
	n = 2;
	Answer = 10;
	//Answer ^= 1 << n;
	Switch(Answer, n);
	
	//분석 : Answer = 10, n == 2일때
	//Answer = 10 ^ 4; 임
	//1010 = 10
	//0100 = 4
	//====
	//1110 = 14

	n = 1;
	Answer = 10;
	//Answer ^= 1 << n;
	Switch(Answer, n);

	//분석 : Answer = 10, n == 1일때
	//Answer = 10 ^ 4; 임
	//1010 = 10
	//0010 = 2
	//====
	//1000 = 8

	//4. n번째 비트값이 1이면 1, 0이면 0을 리턴하는 연산//////////////////////////////////////////////
	bool IsTrue = false;
	Answer = 10;
	IsTrue = IsOn(Answer, 0);//(Answer >> 0) & 1; // false
	IsTrue = IsOn(Answer, 1);//(Answer >> 1) & 1; // true
	IsTrue = IsOn(Answer, 2);//(Answer >> 2) & 1; // false
	IsTrue = IsOn(Answer, 3);//(Answer >> 3) & 1; // true

	return 0;
}